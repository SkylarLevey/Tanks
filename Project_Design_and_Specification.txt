Abe Lusk and Skylar Levey

COM110

Final Project

Problem Design and Specification

A.     The project we have created is a rendition of the classic flash game Tanks. This is a two player game that pits your ballistics skills against your opponent in 1V1 combat. At the start of each game two tank objects(one for each player), and a ground object is created. Each tank starts with 99 health, and comes with a barrel appended to it. The users are able to adjust barrel angle, fire power, and tank position on their turns. They may only move their tank up to five times per turn. They may adjust barrel angle and power as much as they want, although the power cannot exceed 50 or go below zero. They must gauge the distance between the two tanks, taking the wind into account, as well as any ground obstacles that may be obstructing the path to the opposing tank.

    Once a player has finished adjusting his shot, that player clicks fire, and a bullet object is created. This bullet object has a vertical and horizontal velocity calculated based on the angle of the barrel and the fire power. The bullet then takes flight, moving in accordance to its velocities. The vertical velocity is slowly decreased through flight, due to gravity. The horizontal velocity is also adjusted due to the wind. The bullet will move across the screen until it either leaves the confines of the window, hits the ground object, or hits a tank object. If it hits the other tank that is a direct hit, which will deal 50 damage. If it hits the ground it will destroy a portion of the ground, and deal 33 damage to any tank within the blast radius. Once a shot has been completed it is the next player’s turn. They go back and forth, moving and shooting until one tank it finally destroyed. Then they will be informed who is the victor, and given the option to play again or to quit.

B.    In our design of Tanks, we used four different classes. These are the tank class, the ground class, the bullet class, and the interface class. Of these the interface class is the most simple, because it has no methods. The interface class is passed a window, and will create a series of buttons, text boxes, and entry boxes in the given window. Each of these is saved as an instance variable of the class. This class serves two main functions; it cleans up the main function, and it makes it easy to pass all the user interface to the other classes. Some of our other classes and functions change the text boxes on the window, and passing one class is much less cumbersome than passing a whole series of text objects. The interface class only returns an interface object.

    The ground class is the next simplest class. It takes parameters for a window, and a ground list. This ground list must be a series of Point objects that make up the ground. Each point must have an integral x value, one greater than the last point. The y values can be any number on the screen. After all the x values on the screen have been exhausted, ground list must also have a point on the bottom right and bottom left of the screen in order to complete the polygon object that will be drawn. This object is created and drawn in the init of ground, and is saved as an instance variable. Wind is also generated in ground, as a random number between -50 and 50, inclusive. The wind is saved to an instance variable, and is drawn as a text box to the screen so the user can see the magnitude and direction of the wind. The ground class does not return anything. The only method of the ground class is the undraw method. This takes no parameters, and simply undraws the ground object polygon. 

    The tank class is significantly more complex than the ground or the interface class. The tank class takes 5 parameters, for the position of the tank, the ground object the tank will rest on, the window the tank will be drawn to, the position of the text that will show the tank’s health, and the color of the tank. These are saved as instance variables or used immediately. Additional instance variables created in the tank class are self.power, self.health and self.barrelAngle. These are set to 40, 99, and 45 respectively, but will change over the course of a game. In the constructor of the tank class a tank is drawn to the window is was passed in the position in was passed. A barrel is also drawn.

    The methods of the tank class are moveTank, moveBarrel, and changeHealth. moveTank takes a parameter that will be a positive or negative number, with the number representing the magnitude of motion, and the sign representing the direction of the motion. The tank and barrel pictures are moved along the x coordinate in this amount, as long as they are not less than zero or greater than 200 (so the tanks can’t run off the screen). The y position of the point on ground list with the same x position as the tank is then found, and the tank is moved to two above this y position. This allows for side to side movement along the ground, although the tank always remains horizontally oriented. This method can also be called with a movement of zero to get the tank back on the ground in case the ground has moved.

    The moveBarrel method changes the instance variable self.barrelAngle, as well as adjusting the barrel image on the screen. It takes in the new angle, undraws the old barrel, and redraws the new one at the new angle. This is accomplished using simple trigonometry to determine where the endpoint of the barrel should be given any angle. The changeHealth method takes one parameter, the healthIncrament. The instance variable self.health is adjusted according to the incrament, and the text box showing the health on the screen is also updated.

    The last class is the Bullet class, which takes parameters for the two tank objects, the window, the ground object, and the blast radius on the bullet. These parameters are saved as instance variables. Additional instance variables created include a small circular bullet picture. The bullet class has two methods, shoot and explosion. Shoot takes in only the power of the shot. From there is uses the power, wind(it was passed the ground object which has the win), and bullet angle to determine how the bullet will fly through the air. The bullet is drawn and undrawn as is moves across the screen, with small sleep calls in between movement for additional suspense (not actually). Once it leaves the screen, encounters a tank object, or encounters a ground object, the bullet will stop. If the bullet went off the side of the screen, it will simply disappear. If it encountered a tank object, it will create a small explosion and deal 50 damage to the tank. If it encountered a ground object, is will blast away the surrounding ground. All points in ground list within the blast radius of the bullet are moved out of the blast radius. The x value of the points never changes, because otherwise our method for determining if the bullet has hit the ground, as well as out method for moving the tank would be jeopardized. If a tank object is in the blast radius of the bullet, that tank is dealt 33 damage. After all this is done, both takes are called to move(0), which will put them back on the ground if the ground moved. The ground object is then undrawn, and the new ground list is returned, which will be used to draw the new ground object. 

    The explosion method takes in a point where the explosion will occur. It then draws three concentric circles around this point, one at a time with a small sleep call in between. The colors of the circles are yellow, orange and then red, to create an explosion.

    In addition to these classes, our Program has four functions outside the main. These are instructionPage, playAgain, mapOption, and tankTurn. We used functions instead of classes for these because we saw no real benefit to putting them in classes. They are all fairly specific to this program, and work perfectly well as functions. instructionPage gets passed a window, and instructs the user on how to play the game. It informs the user which tank will go first, and also takes user input for which map they would like to play on. The map option is returned. mapOption is a function that takes one parameter, which represents the map the user chose to play on. Depending on which option was given, a list of points is created that will be passed to ground to make the ground object. The different map options are a flat map, a valley map, a mountain map, a hilly map, and a random map. The random map is generated from both sides by incrementing the y value of the next point by a random number between -2 and 2, inclusive. These two sides of the map will likely not line up perfectly, so there is a jump in the middle.

    The tankTurn function calls itself recursively until the user quits or one of the tanks dies. This function is passed both the tank objects, the ground object, the window, and the interface object. At the start of the function there is a conditional that checks to make sure both the tanks are alive. If they are, the numbers on the screen representing health, power, and barrel angle are changed to what they were at the end of the tank’s previous turn. The function then takes mouse clicks so the user can use all the buttons available to them. This continues in a while loop indefinitely until the player presses fire. At this point a bullet object is created, and it is called to shoot, with the tank’s power. Shoot returns a new ground list, and that is used to redraw the new ground. tankTurn is then calls itself, with the new ground object, and the position of the tanks in the parameters switched, so the other tank gets to take a turn. If the quit button is ever clicked, two new buttons will pop up and the user can then choose to quit or play again. 

The playAgain function is called at the end of a game. It tells the user who won, and offers them the choice to quit or to play again. This choice is returned to the main, and it will either continue the play again while loop, or break it and end the program if the player chose quit.

    All that is left is the main function. The main function is quite simple. It creates a window, and then calls on the classes and functions to do the heavy lifting. There is one while loop that will start new games if the user keeps pressing play again, and will break and end the program if the user quits. 


C.    Our testing of this program mostly includes playing it over and over again. We have found countless bugs during development, some more difficult to handle than others. If we were to do improve this program there are a few modifications we would make. First of all, we could make a variety of different bullets. The blast radius of the bullet objects is easy to change because it is just an instance variable of the bullet. We could implement a monetary system where player play a set of games, and get the chance to buy different bullets after each game. We could would also like to make the game such that more than two people can play at once. This would pose some challenges, but we think it would be within our abilities.

    A potential change to the way the game works is changing the ground object. The current ground object works, which was our main goal, but it is far from perfect. One of the major issues it has is that very steep inclines do not get additional points in ground list. When the bullet object has a y value beneath the y value of the ground at the bullet’s x value, the bullet determines it has hit the ground at the point in ground list that share’s the bullet’s x value. On a steep incline, the bullet hit the middle of the slope but create an explosion at the top, due to a lack of points on between. Our ground also can never have two y values at a specific x value. This makes tunneling and overhangs impossible.

    A potential solution to these problems is to create the ground on a grid system. The entire map will be ground, but the each point in the ground will be either on or off. If it is on it will be colored green, and if it is off is will be colored white. Ground that is off is ignored, while ground that is on is treated as ground. This type of grid system ground would result in some improvement of the program, but it would be quite difficult to implement, and would involve major restructuring of our code. It also may have unforeseen problems that our current ground was able to avoid.
